name: Build and Sign macOS App

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths-ignore:
      - 'README.md'
      - '.github/**'
      - '!.github/workflows/build.yml'
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: macos-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
        
    - name: Install the Apple certificate
      env:
        CERTIFICATE_BASE64: ${{ secrets.CERTIFICATE_BASE64 }}
        CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      run: |
        # Create a temporary file for the certificate
        CERTIFICATE_PATH=$RUNNER_TEMP/developer_id_cert.p12
        
        # Decode the base64 certificate into the temporary file
        echo -n "$CERTIFICATE_BASE64" | base64 --decode > $CERTIFICATE_PATH
        
        # Create a keychain
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        
        # Import the certificate to the keychain
        security import $CERTIFICATE_PATH -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
        security list-keychain -d user -s $KEYCHAIN_PATH
        
        # Verify the certificate was imported correctly
        security find-identity -v -p codesigning $KEYCHAIN_PATH
        
    - name: Install provisioning profile
      env:
        PROVISIONING_PROFILE_BASE64: ${{ secrets.PROVISIONING_PROFILE_BASE64 }}
      run: |
        # Debug: Show environment information
        echo "Running as user: $(whoami)"
        echo "Home directory: $HOME"
        
        # Create the profiles directory with explicit permissions
        PROFILES_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
        echo "Creating profiles directory at: $PROFILES_DIR"
        mkdir -p "$PROFILES_DIR"
        
        # Debug: Check if directory was created
        if [ -d "$PROFILES_DIR" ]; then
          echo "‚úÖ Profiles directory created successfully"
          ls -la "$PROFILES_DIR"
        else
          echo "‚ùå Failed to create profiles directory"
          echo "Checking parent directories:"
          ls -la "$HOME/Library/MobileDevice" || echo "MobileDevice directory doesn't exist"
          ls -la "$HOME/Library" || echo "Library directory doesn't exist"
          exit 1
        fi
        
        # Create a temporary file for the profile and verify it's properly decoded
        TEMP_PROFILE=$RUNNER_TEMP/profile.provisionprofile
        echo -n "$PROVISIONING_PROFILE_BASE64" | base64 --decode > $TEMP_PROFILE
        
        # Check if the file was created and has content
        if [ ! -s "$TEMP_PROFILE" ]; then
          echo "ERROR: Failed to decode provisioning profile. Check the base64 encoding."
          exit 1
        fi
        
        echo "‚úÖ Profile decoded successfully, size: $(wc -c < $TEMP_PROFILE) bytes"
        
        # Check file type
        echo "File type:"
        file "$TEMP_PROFILE" || echo "Could not determine file type"
        
        # Use timestamp as fallback UUID
        TIMESTAMP=$(date +%s)
        
        # Try various methods to extract UUID
        echo "Attempting to extract UUID from profile..."
        
        # Method 1: Simple grep for UUID pattern
        UUID=$(strings "$TEMP_PROFILE" | grep -o "[-A-Z0-9]\{36\}" | head -1)
        if [ -n "$UUID" ]; then
          echo "Found UUID using simple pattern match: $UUID"
        else
          echo "No UUID pattern found, trying alternate methods..."
          
          # Method 2: Extract using strings and searching for UUID key
          UUID=$(strings "$TEMP_PROFILE" | grep -A 1 "UUID" | grep -v "UUID" | grep -o "[a-zA-Z0-9-]\{1,\}" | head -1)
          if [ -n "$UUID" ]; then
            echo "Found UUID using strings and UUID key: $UUID"
          else
            echo "No UUID found near UUID key, using timestamp instead: $TIMESTAMP"
            UUID=$TIMESTAMP
          fi
        fi
        
        echo "Using profile identifier: $UUID"
        PROFILE_PATH="$PROFILES_DIR/$UUID.provisionprofile"
        cp "$TEMP_PROFILE" "$PROFILE_PATH"
        
        # Check if the copy succeeded
        if [ -f "$PROFILE_PATH" ]; then
          echo "‚úÖ Provisioning profile installed successfully at: $PROFILE_PATH"
          ls -la "$PROFILE_PATH"
          echo "Installed profiles:"
          ls -la "$PROFILES_DIR"
        else
          echo "‚ùå Failed to copy provisioning profile to $PROFILE_PATH"
          echo "Checking permissions:"
          ls -la "$PROFILES_DIR"
          exit 1
        fi
        
    - name: Create export options file
      run: |
        echo '<?xml version="1.0" encoding="UTF-8"?>' > exportOptions.plist
        echo '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' >> exportOptions.plist
        echo '<plist version="1.0">' >> exportOptions.plist
        echo '<dict>' >> exportOptions.plist
        echo '    <key>method</key>' >> exportOptions.plist
        echo '    <string>developer-id</string>' >> exportOptions.plist
        echo '    <key>teamID</key>' >> exportOptions.plist
        echo '    <string>43TJNHX42U</string>' >> exportOptions.plist
        echo '    <key>signingStyle</key>' >> exportOptions.plist
        echo '    <string>manual</string>' >> exportOptions.plist
        echo '    <key>provisioningProfiles</key>' >> exportOptions.plist
        echo '    <dict>' >> exportOptions.plist
        echo '        <key>com.foxycorps.Review</key>' >> exportOptions.plist
        echo '        <string>Review Developer ID</string>' >> exportOptions.plist
        echo '    </dict>' >> exportOptions.plist
        echo '    <key>signingCertificate</key>' >> exportOptions.plist
        echo '    <string>Developer ID Application</string>' >> exportOptions.plist
        echo '    <key>skipPackagePluginValidation</key>' >> exportOptions.plist
        echo '    <true/>' >> exportOptions.plist
        echo '    <key>compileBitcode</key>' >> exportOptions.plist
        echo '    <false/>' >> exportOptions.plist
        echo '</dict>' >> exportOptions.plist
        echo '</plist>' >> exportOptions.plist
        
        echo "‚úÖ Created exportOptions.plist:"
        cat exportOptions.plist
        
    - name: Build and Archive
      run: |
        # First, let's check the project setup
        echo "üìÇ Project files:"
        ls -la
        
        # Create build directory
        mkdir -p ./build
        
        # Build the project with special handling for package dependencies
        echo "üî® Building and archiving project..."
        xcodebuild archive \
          -project Review.xcodeproj \
          -scheme Review \
          -archivePath ./build/Review.xcarchive \
          -destination "generic/platform=macOS" \
          CODE_SIGN_IDENTITY="Developer ID Application" \
          DEVELOPMENT_TEAM=43TJNHX42U \
          OTHER_CODE_SIGN_FLAGS="--options=runtime" \
          | xcpretty || { echo "‚ùå Archive failed"; exit 1; }
          
        # Check if archive was successful
        if [ ! -d "./build/Review.xcarchive" ]; then
          echo "‚ùå ERROR: Archive failed to create"
          exit 1
        fi
        
        echo "‚úÖ Archive created successfully at ./build/Review.xcarchive"
        
    - name: Export Archive
      run: |
        # Export the archive using our custom exportOptions.plist
        echo "üì¶ Exporting archive..."
        xcodebuild -exportArchive \
          -archivePath ./build/Review.xcarchive \
          -exportPath ./build/Export \
          -exportOptionsPlist exportOptions.plist \
          | xcpretty || { echo "‚ùå Export failed"; exit 1; }
          
        # Check if export was successful
        if [ ! -d "./build/Export/Review.app" ]; then
          echo "‚ùå ERROR: Export failed to create the app"
          exit 1
        fi
        
        echo "‚úÖ App exported successfully to ./build/Export/Review.app"
        
    - name: Notarize App
      env:
        APP_SPECIFIC_PASSWORD: ${{ secrets.APP_SPECIFIC_PASSWORD }}
      run: |
        # Create a temporary file to store the password
        PASS_TEMP_FILE=$RUNNER_TEMP/notarize_password
        echo -n "$APP_SPECIFIC_PASSWORD" > "$PASS_TEMP_FILE"
        
        # Create a ZIP for notarization
        echo "üîê Creating ZIP for notarization..."
        ditto -c -k --keepParent "./build/Export/Review.app" "./build/Review.zip"
        
        # Submit for notarization
        echo "üì§ Submitting app for notarization..."
        xcrun notarytool submit "./build/Review.zip" \
          --apple-id "slyfoxalpha@gmail.com" \
          --team-id "43TJNHX42U" \
          --password "$PASS_TEMP_FILE" \
          --wait
          
        # Remove the password file
        rm "$PASS_TEMP_FILE"
        
        # Staple the notarization ticket
        echo "üìù Stapling notarization ticket to app..."
        xcrun stapler staple "./build/Export/Review.app"
        
        echo "‚úÖ App notarized and stapled successfully"
        
    - name: Create DMG
      run: |
        # Create a temporary directory for DMG creation
        echo "üíø Creating DMG..."
        TEMP_DMG_DIR=$RUNNER_TEMP/dmg_temp
        mkdir -p "$TEMP_DMG_DIR"
        
        # Copy the app to the temporary directory
        cp -R "./build/Export/Review.app" "$TEMP_DMG_DIR/"
        
        # Create a symlink to /Applications for easy installation
        ln -s /Applications "$TEMP_DMG_DIR/"
        
        # Create the DMG
        hdiutil create -volname "Review" -srcfolder "$TEMP_DMG_DIR" -ov -format UDZO "./build/Review.dmg"
        
        # Check if DMG was created successfully
        if [ ! -f "./build/Review.dmg" ]; then
          echo "‚ùå ERROR: Failed to create DMG"
          exit 1
        fi
        
        echo "‚úÖ DMG created successfully at ./build/Review.dmg"
        
    - name: Upload app
      uses: actions/upload-artifact@v4
      with:
        name: Review.app
        path: build/Export/Review.app
        
    - name: Upload DMG
      uses: actions/upload-artifact@v4
      with:
        name: Review.dmg
        path: build/Review.dmg 